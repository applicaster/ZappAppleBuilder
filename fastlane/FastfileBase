require 'dotenv'

Dotenv.load

platform :ios do

  def create_temp_keychain()
    create_keychain(
      name: keychain_name,
      password: keychain_password,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: true
    )
  end

  def create_app_on_dev_portal(username, team_id, app_name, app_bundle, app_index)
    # create app on developer portal with new identifier for notification extension
    produce(
      username: "#{username}",
      app_identifier: "#{app_bundle}",
      team_id: "#{team_id}",
      app_name: "#{app_name}",
      language: "English",
      app_version: "1.0",
      sku: "#{app_bundle}.#{app_index}",
      skip_itc: true,
      enable_services: {
        app_group: "on",
        associated_domains: "on",
        data_protection: "complete",
        in_app_purchase: "on",
        push_notification: "on",
        access_wifi: "on"
      }
    )

  end

  def create_provisioning_profile(username, team_id, team_name, app_bundle)
    # create download and install new provisioning profile for the app
    sigh(
      username: "#{username}",
      app_identifier: "#{app_bundle}",
      team_id: "#{team_id}",
      provisioning_name: "#{app_bundle} prov profile",
      cert_owner_name: "#{team_name}",
      filename: "#{app_bundle}.mobileprovision",
      platform: platform_name
    )

    ENV["#{app_bundle}_PROFILE_UDID"] = lane_context[SharedValues::SIGH_UDID]

    # delete Invalid provisioning profiles for the same app
    delete_invalid_provisioning_profiles(username, team_id, app_bundle)
  end

  def remove_app_extensions_from_project(target_name)
    update_zapp_app_target do |target|
      target.dependencies.reject! do |dependency|
         dependency.target.name == "#{target_name}"
      end

      target.build_phases.reject! do |phase|
        phase.is_a?(Xcodeproj::Project::Object::PBXCopyFilesBuildPhase) && phase.name == "Embed App Extensions"
      end
    end
  end

  def change_system_capability(capability, old_value, new_value)
      project = "#{xcodeproj_path}/project.pbxproj"
      regex = /(#{capability} = {\s+enabled\s=\s)#{old_value}(;\s+};)/
      substitue = %Q(\\1#{new_value}\\2)
      new_content = File.read(project).gsub!(regex, substitue)
      File.write(project, new_content) if new_content
  end

  def update_zapp_app_target()
    require 'xcodeproj'

    project = Xcodeproj::Project.open("#{xcodeproj_path}")
    target = project.native_targets.find {|s| s.name == "#{project_scheme}" }

    yield(target)

    project.save
  end

  def update_group_identifiers(target, build_type, groups)
    file_path = "#{project_path}/#{target}/Entitlements/#{target}-#{build_type}.entitlements"

    update_app_group_identifiers(
      entitlements_file: "#{file_path}",
      app_group_identifiers: groups
    )
  end

  def remove_key_from_entitlements(target, build_type, key)
    file_path = "#{project_path}/#{target}/Entitlements/#{target}-#{build_type}.entitlements"

    sh("echo $(/usr/libexec/PlistBuddy -c \"Delete :#{key}\" #{file_path} 2>/dev/null)")
  end


  def reset_to_bundle_identifier_placeholder(proj_path, info_plist_path)
    update_info_plist(
      xcodeproj: proj_path,
      plist_path: info_plist_path,
      block: lambda do |plist|
        plist['CFBundleIdentifier'] = "$(PRODUCT_BUNDLE_IDENTIFIER)"
      end
    )
  end

  def update_target_info_plist_values(target_name, target_bundle_identifier)
    # update app identifier, versions of the extension
    bundle_version = get_info_plist_value(
      path: project_info_plist_path,
      key: "CFBundleVersion"
    )
    bundle_short_version = get_info_plist_value(
      path: project_info_plist_path,
      key: "CFBundleShortVersionString"
    )
    update_info_plist(
      xcodeproj: xcodeproj_path,
      plist_path: "#{target_name}/Info.plist",
      block: lambda do |plist|
        plist['CFBundleVersion'] = bundle_version
        plist['CFBundleShortVersionString'] = bundle_short_version
      end
    )

    # update app identifier to the enterprise one
    update_app_identifier(
      xcodeproj: xcodeproj_path,
      plist_path: "#{target_name}/Info.plist",
      app_identifier: target_bundle_identifier
    )

  end

  def custom_update_service(username, team_id, app_bundle, service_id)
    password = ENV['FASTLANE_PASSWORD']
    Spaceship::Portal.login(username, password)
    Spaceship::Portal.client.team_id = team_id
    app = Spaceship::Portal.app.find("#{app_bundle}")
    app.update_service(Spaceship::Portal::AppService.new_service("#{service_id}").on)

    sh("echo Update for service #{service_id} completed successfully")
  end

  def delete_invalid_provisioning_profiles(username, team_id, app_bundle)
    password = ENV['FASTLANE_PASSWORD']
    Spaceship::Portal.login(username, password)
    Spaceship::Portal.client.team_id = team_id

    profiles = Spaceship::Portal::ProvisioningProfile.all.find_all do |profile|
      (profile.status == "Invalid" or profile.status == "Expired") && profile.app.bundle_id == app_bundle
    end

    profiles.each do |profile|
      sh("echo 'Deleting #{profile.name}, status: #{profile.status}'")
      profile.delete!
    end
  end

  def create_push_certificate(username, team_id, team_name, app_bundle, p12_password)
    get_push_certificate(
      username: "#{username}",
      team_id: "#{team_id}",
      team_name: "#{team_name}",
      app_identifier: "#{app_bundle}",
      generate_p12: true,
      p12_password: "#{p12_password}",
      pem_name: "apns",
      save_private_key: false,
      output_path: "./CircleArtifacts"
    )

    command = "bundle exec "\
    "rake upload_enterprise_push:upload_certificate["\
    "#{ENV['accounts_account_id']},"\
    "#{ENV['bundle_identifier']},"\
    "#{circle_artifacts_folder_path},"\
    "apns.p12]"

    sh("#{command}")
  end

  def firebase_add_configuration_file(configuration)
    base_folder = "#{project_path}/#{project_name}"

    filepath = "#{base_folder}/.firebase/#{configuration}/GoogleService-Info.plist"
    if File.exist? filepath
    FileUtils.cp(filepath, base_folder)
    File.delete(filepath)
    end
  end

  def ms_app_center_update_app_secret(bundle_identifier)
    ms_app_center_app_secret = ms_app_center_read_value_from_file(bundle_identifier, "appsecret")

    sh("/usr/libexec/PlistBuddy -c \"Set MSAppCenterAppSecret #{ms_app_center_app_secret}\" #{customizations_folder_path}/FeaturesCustomization.plist")
    puts "MS App Center app secret #{ms_app_center_app_secret} was updated successfully for bundle identifier: #{bundle_identifier}"

    # add appcenter url scheme to the app
    update_url_schemes(
      path: "#{project_info_plist_path}",
      update_url_schemes: proc do |schemes|
        schemes + ["appcenter-#{ms_app_center_app_secret}"]
      end
    )
  end

  def ms_app_center_read_value_from_file(bundle_identifier, type)
    folder_name = ".ms_app_center"
    filename = "#{ENV['PWD']}/#{folder_name}/#{bundle_identifier}_#{type}"
    if File.exist? "#{filename}"
       File.read("#{filename}").strip
    end
  end

  def ms_app_center_upload_app(bundle_identifier, build_type, zapp_build_type)

    ms_app_center_app_display_name = app_name
    ms_app_center_app_name = ms_app_center_read_value_from_file(bundle_identifier, "appname")
    ms_app_center_app_secret = ms_app_center_read_value_from_file(bundle_identifier, "appsecret")
    ms_app_center_app_distribution_group = ms_app_center_read_value_from_file(bundle_identifier, "appgroup")
    ms_app_center_app_platform = "Objective-C-Swift"
    ms_app_center_app_os = appCenterDeviceIdentifier

    puts("#{ENV['APPCENTER_API_TOKEN']}
      #{ENV['APPCENTER_OWNER_NAME']}
      #{ms_app_center_app_distribution_group}
      #{ms_app_center_app_os}
      #{ms_app_center_app_platform}
      #{ms_app_center_app_display_name}
      #{circle_artifacts_folder_path}/#{build_type}/#{project_scheme}-#{build_type}.ipa
       #{circle_artifacts_folder_path}/#{build_type}/#{project_scheme}-#{build_type}.app.dSYM.zip"
       )
    appcenter_upload(
      api_token: "#{ENV['APPCENTER_API_TOKEN']}",
      owner_name: "#{ENV['APPCENTER_OWNER_NAME']}",
      destinations: "#{ms_app_center_app_distribution_group}",
      destination_type: "group",
      app_os: "#{ms_app_center_app_os}",
      app_platform: "#{ms_app_center_app_platform}",
      app_display_name: "#{ms_app_center_app_display_name}",
      app_name: "#{ms_app_center_app_name}",
      ipa: "#{circle_artifacts_folder_path}/#{build_type}/#{project_scheme}-#{build_type}.ipa",
      dsym: "#{circle_artifacts_folder_path}/#{build_type}/#{project_scheme}-#{build_type}.app.dSYM.zip",
      notify_testers: false # Set to false if you don't want to notify testers of your new release (default: `false`)
    )

    # save uploaded app info to file for future use
    save_build_params_for_type(bundle_identifier, build_type, ms_app_center_app_name, ms_app_center_app_secret)

  end

  def save_build_params_for_type(bundle_identifier, build_type, app_name, app_secret)
    folder_name = "#{ENV['PWD']}/.ms_app_center"
    filename = "#{folder_name}/#{build_type}_upload_params.json"
    hash = build_params_hash_for_type(bundle_identifier, build_type, app_name, app_secret)
    Dir.mkdir(folder_name) unless File.exists?(folder_name)
    File.open(filename,"w") do |f|
       f.write(hash.to_json)
    end
  end

  def build_params_hash_for_type(bundle_identifier, build_type, app_name, app_secret)
    if isTvOS
      time = Time.new
      s3DestinationPathParams = s3_upload_path(bundle_identifier)
      s3DistanationPath = "https://assets-secure.applicaster.com/#{s3DestinationPathParams}/#{project_scheme}-#{build_type}.ipa"
      {
        uploaded_at: time.inspect,
        download_url: s3DistanationPath,
      }
    else
      release_info = lane_context[SharedValues::APPCENTER_BUILD_INFORMATION]
      {
        uploaded_at: release_info["uploaded_at"],
        download_url: release_info["download_url"],
        install_url: release_info["install_url"],
        id: release_info["id"],
        app_name: app_name,
        app_secret: app_secret
      }
    end
  end

  def s3_upload_path(bundle_identifier)
    puts("s3_upload_path #{bundle_identifier}")
    "zapp/accounts/#{accountsAccountId}/apps/#{bundle_identifier}/#{store}/#{version_name}/tvos/#{build_version}"
  end

  def capture_stream(stream)
    raise ArgumentError, 'missing block' unless block_given?
    orig_stream = stream.dup
    IO.pipe do |r, w|
      # system call dup2() replaces the file descriptor
      stream.reopen(w)
      # there must be only one write end of the pipe;
      # otherwise the read end does not get an EOF
      # by the final `reopen`
      w.close
      t = Thread.new { r.read }
      begin
        yield
      ensure
        stream.reopen orig_stream # restore file descriptor
      end
      t.value # join and get the result of the thread
    end
  end
end
